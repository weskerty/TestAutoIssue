name: 'Procesar Issues Autom√°ticamente'

on:
  issues:
    types: [opened, edited]

jobs:
  process-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Create temporary directory and install dependencies
        run: |
          mkdir -p /tmp/issue-processor
          cd /tmp/issue-processor
          npm init -y
          npm install node-fetch form-data cheerio sharp

      - name: Process Issue
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_USER: ${{ github.event.issue.user.login }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
        run: |
          cd /tmp/issue-processor
          cat > process_issue.js << 'EOF'
          const fs = require('fs').promises;
          const path = require('path');
          const { exec } = require('child_process');
          const { promisify } = require('util');
          const cheerio = require('cheerio');

          const execAsync = promisify(exec);

          const CONFIG = {
            targetDir: path.join(process.env.GITHUB_WORKSPACE, 'web/Dinamico/Corrupcion'),
            groqApiKey: process.env.GROQ_API_KEY,
            githubToken: process.env.GITHUB_TOKEN,
            baseCommitMessage: 'Nueva Entrada:',
            botSignature: 'IssueBot',
            maxFilenameLength: 100,
            
            imagePrompt: `Analiza esta imagen y responde √öNICAMENTE con "APTA" o "NO_APTA".
            
            Una imagen es APTA si:
            - Es apropiada para todo p√∫blico
            - No contiene contenido sexual, pornogr√°fico o desnudos
            - No contiene violencia extrema o gore
            - Es relevante para contenido informativo/period√≠stico
            
            Una imagen es NO_APTA si:
            - Contiene desnudos o contenido sexual
            - Muestra violencia extrema o sangre excesiva
            - Es claramente inapropiada para menores
            
            Responde solo: APTA o NO_APTA`,

            textPrompt: `Analiza el siguiente texto y fuentes, y responde √öNICAMENTE con "VALIDO" o "INVALIDO".
            
            El texto es V√ÅLIDO si:
            - Tiene coherencia y estructura l√≥gica
            - Presenta informaci√≥n detallada y espec√≠fica
            - Las fuentes son enlaces v√°lidos y relevantes
            - No es claramente spam, troll, discurso de odio o sin sentido
            - Tiene al menos 500 caracteres de contenido sustancial
            - Las fuentes proporcionan contexto o evidencia
            
            El texto es INV√ÅLIDO si:
            - Es muy corto o sin informaci√≥n √∫til
            - Es claramente spam, troll, discurso de odio o sin sentido
            - Las fuentes no son relevantes o son falsas
            - Contiene solo texto sin sentido
            - No aporta informaci√≥n valiosa
            - Contiene Scripts Sospechosos no relacionado a reproduccion multimedia
            
            Responde solo: VALIDO o INVALIDO`
          };

          class IssueProcessor {
            constructor() {
              this.issueNumber = process.env.ISSUE_NUMBER;
              this.issueTitle = process.env.ISSUE_TITLE;
              this.issueBody = process.env.ISSUE_BODY;
              this.issueUser = process.env.ISSUE_USER;
              this.imageBuffer = null;
            }

            async makeGroqRequest(prompt, imageBuffer = null) {
              const fetch = (await import('node-fetch')).default;
              
              let messages = [];
              
              if (imageBuffer) {
                const imageDataUrl = `data:image/jpeg;base64,${imageBuffer.toString('base64')}`;
                messages.push({
                  role: 'user',
                  content: [
                    { type: 'text', text: prompt },
                    { type: 'image_url', image_url: { url: imageDataUrl } }
                  ]
                });
              } else {
                messages.push({
                  role: 'user',
                  content: prompt
                });
              }

              const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${CONFIG.groqApiKey}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  messages,
                  model: imageBuffer ? 'meta-llama/llama-4-maverick-17b-128e-instruct' : 'llama-3.3-70b-versatile',
                  temperature: 0.1,
                  max_tokens: 100
                })
              });

              if (!response.ok) {
                throw new Error(`Groq API Error: ${response.status}`);
              }

              const data = await response.json();
              return data.choices[0].message.content.trim();
            }

            parseIssueBodyHTML(body) {
              const $ = cheerio.load(body);
              const sections = {
                title: '',
                description: '',
                fuentes: []
              };

              $('h3').each((i, el) => {
                const heading = $(el).text().trim();
                const content = $(el).next('p').text().trim();
                
                if (heading.includes('T√≠tulo')) {
                  sections.title = content;
                } else if (heading.includes('Descripci√≥n')) {
                  sections.description = content;
                } else if (heading.includes('Fuentes')) {
                  const fuentesText = content;
                  const urlRegex = /https?:\/\/[^\s<>"{}|\\^`\[\]]+/g;
                  const urls = fuentesText.match(urlRegex) || [];
                  sections.fuentes = [...new Set(urls)];
                }
              });

              if (!sections.title || !sections.description || sections.fuentes.length === 0) {
                return this.parseIssueBodyFallback(body);
              }

              return sections;
            }

            parseIssueBodyFallback(body) {
              const sections = {
                title: '',
                description: '',
                fuentes: []
              };

              const titleMatch = body.match(/### üìå T√≠tulo\s*\n\n(.*?)(?=\n### |$)/s);
              if (titleMatch) {
                sections.title = titleMatch[1].trim();
              }

              const descMatch = body.match(/### üìù Descripci√≥n\s*\r?\n+([\s\S]*?)(?=\n### |$)/);
              if (descMatch) {
                sections.description = descMatch[1].trim();
              }

              const fuentesMatch = body.match(/### üîó Fuentes\s*\n\n(.*?)(?=\n### |$)/s);
              if (fuentesMatch) {
                const fuentesText = fuentesMatch[1].trim();
                const urlRegex = /https?:\/\/[^\s<>"{}|\\^`\[\]]+/g;
                const urls = fuentesText.match(urlRegex) || [];
                const lines = fuentesText.split('\n');
                const lineUrls = lines
                  .map(line => line.trim())
                  .filter(line => line.startsWith('-') || line.startsWith('*'))
                  .map(line => {
                    const match = line.match(/https?:\/\/[^\s<>"{}|\\^`\[\]]+/);
                    return match ? match[0] : null;
                  })
                  .filter(url => url !== null);
                
                const allUrls = [...new Set([...urls, ...lineUrls])];
                sections.fuentes = allUrls;
              }

              return sections;
            }

            extractFirstImage(body) {
              const markdownRegex = /!\[.*?\]\((https?:\/\/[^\)]+)\)/;
              const markdownMatch = body.match(markdownRegex);
              if (markdownMatch) return markdownMatch[1];
              
              const htmlRegex = /<img[^>]+src=["']([^"']+)["'][^>]*>/;
              const htmlMatch = body.match(htmlRegex);
              if (htmlMatch) return htmlMatch[1];
              
              const githubAssetsRegex = /https:\/\/github\.com\/user-attachments\/assets\/[a-f0-9\-]+/;
              const assetsMatch = body.match(githubAssetsRegex);
              if (assetsMatch) return assetsMatch[0];
              
              return null;
            }

            sanitizeFilename(filename) {
              let sanitized = filename
                .replace(/[<>:"/\\|?*#@!$%^&()+={}[\]~`]/g, '')
                .replace(/[\s\-]+/g, '_')
                .replace(/\.{2,}/g, '.')
                .replace(/^\.+|\.+$/g, '')
                .replace(/[^\w._]/g, '')
                .toLowerCase()
                .replace(/_{2,}/g, '_')
                .replace(/^_+|_+$/g, '');

              if (!sanitized || sanitized === '') {
                sanitized = 'entrada_sin_nombre';
              }

              if (sanitized.length > CONFIG.maxFilenameLength) {
                sanitized = sanitized.substring(0, CONFIG.maxFilenameLength);
                sanitized = sanitized.replace(/_+$/, '');
              }

              if (/^\d/.test(sanitized)) {
                sanitized = 'entrada_' + sanitized;
              }

              return sanitized;
            }

            async fileExists(filepath) {
              try {
                await fs.access(filepath);
                return true;
              } catch {
                return false;
              }
            }

            async findAvailableFilename(baseFilename, username) {
              const basePath = path.join(CONFIG.targetDir, `${baseFilename}.md`);
              
              if (!(await this.fileExists(basePath))) {
                return { filename: baseFilename, isNew: true };
              }

              try {
                const existingContent = await fs.readFile(basePath, 'utf8');
                const existingUser = this.extractUserFromFile(existingContent);
                
                if (username && existingUser === username) {
                  return { filename: baseFilename, canReplace: true };
                }
                
                let counter = 1;
                let newFilename;
                let newPath;
                
                do {
                  newFilename = `${baseFilename}_${counter}`;
                  newPath = path.join(CONFIG.targetDir, `${newFilename}.md`);
                  counter++;
                } while (await this.fileExists(newPath));
                
                return { filename: newFilename, isNew: true };
                
              } catch (error) {
                console.error('Error leyendo archivo existente:', error);
                
                let counter = 1;
                let newFilename;
                let newPath;
                
                do {
                  newFilename = `${baseFilename}_${counter}`;
                  newPath = path.join(CONFIG.targetDir, `${newFilename}.md`);
                  counter++;
                } while (await this.fileExists(newPath));
                
                return { filename: newFilename, isNew: true };
              }
            }

            extractUserFromFile(content) {
              const match = content.match(/<!-- participant: (\w+) -->/);
              return match ? match[1] : null;
            }

            async downloadAndProcessImage(imageUrl) {
              const fetch = (await import('node-fetch')).default;
              
              console.log(`üì• Descargando imagen desde: ${imageUrl}`);
              
              let headers = {};
              if (imageUrl.includes('github.com/user-attachments/assets')) {
                headers['Authorization'] = `token ${CONFIG.githubToken}`;
                headers['Accept'] = 'application/vnd.github.v3.raw';
              }
              
              const response = await fetch(imageUrl, { headers });
              
              if (!response.ok) {
                throw new Error(`Error descargando imagen: ${response.status}`);
              }

              const buffer = await response.buffer();
              console.log(`üì¶ Imagen descargada, tama√±o: ${buffer.length} bytes`);
              
              try {
                const sharp = require('sharp');
                const cleanedBuffer = await sharp(buffer)
                  .jpeg({ quality: 90 })
                  .removeAlpha()
                  .withMetadata({})
                  .toBuffer();
                
                console.log('üßπ Metadatos removidos de la imagen');
                this.imageBuffer = cleanedBuffer;
                return cleanedBuffer;
              } catch (sharpError) {
                console.warn('‚ö†Ô∏è No se pudo limpiar metadatos, usando imagen original');
                this.imageBuffer = buffer;
                return buffer;
              }
            }

            async saveProcessedImage(filename) {
              if (!this.imageBuffer) {
                throw new Error('No hay imagen procesada para guardar');
              }
              
              const imagePath = path.join(CONFIG.targetDir, `${filename}.jpg`);
              await fs.writeFile(imagePath, this.imageBuffer);
              console.log(`üíæ Imagen guardada en: ${imagePath}`);
              return imagePath;
            }

            async validateContent(description, fuentes, imageBuffer) {
              console.log('üîç Validando contenido con IA...');

              if (imageBuffer) {
                console.log('üì∏ Validando imagen...');
                
                try {
                  const imageResult = await this.makeGroqRequest(CONFIG.imagePrompt, imageBuffer);
                  console.log(`Resultado imagen: ${imageResult}`);
                  
                  if (imageResult.includes('NO_APTA')) {
                    throw new Error('La imagen no es apropiada para todo p√∫blico. Sigue las Reglas.');
                  }
                } catch (imageError) {
                  if (imageError.message.includes('Sigue las Reglas')) {
                    throw imageError;
                  }
                  console.warn(`‚ö†Ô∏è No se pudo validar la imagen: ${imageError.message}`);
                }
              }

              console.log('üìù Validando texto y fuentes...');
              const textToValidate = `
              DESCRIPCI√ìN:
              ${description}
              
              FUENTES:
              ${fuentes.join('\n')}
              `;
              
              const textResult = await this.makeGroqRequest(CONFIG.textPrompt + '\n\nTEXTO A ANALIZAR:\n' + textToValidate);
              console.log(`Resultado texto: ${textResult}`);
              
              if (textResult.includes('INVALIDO')) {
                throw new Error('El contenido del texto o las fuentes no son v√°lidos. Sigue las Reglas.');
              }

              console.log('‚úÖ Validaci√≥n exitosa');
              return true;
            }

            async createMarkdownFile(filename, title, description, fuentes, username) {
              let content = '';
              if (username) {
                content += `<!-- participant: ${username} -->\n\n`;
              }
              
              content += `# ${title}\n\n`;
              content += `${description}\n\n`;
              
              if (fuentes.length > 0) {
                content += `## Fuentes\n\n`;
                fuentes.forEach(fuente => {
                  content += `- ${fuente}\n`;
                });
              }

              const filePath = path.join(CONFIG.targetDir, `${filename}.md`);
              await fs.writeFile(filePath, content, 'utf8');
              return filePath;
            }

            async addComment(message, isError = false) {
              const fetch = (await import('node-fetch')).default;
              
              const commentBody = isError ? 
                `‚ùå **Error**: ${message}` : 
                `‚úÖ **√âxito**: ${message}`;

              await fetch(`https://api.github.com/repos/${process.env.GITHUB_REPOSITORY}/issues/${this.issueNumber}/comments`, {
                method: 'POST',
                headers: {
                  'Authorization': `token ${CONFIG.githubToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ body: commentBody })
              });
            }

            async closeIssue() {
              const fetch = (await import('node-fetch')).default;
              
              await fetch(`https://api.github.com/repos/${process.env.GITHUB_REPOSITORY}/issues/${this.issueNumber}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `token ${CONFIG.githubToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ state: 'closed' })
              });
            }

            async process() {
              try {
                console.log(`üöÄ Procesando issue #${this.issueNumber} de ${this.issueUser}`);

                if (!CONFIG.groqApiKey) {
                  throw new Error('GROQ_API_KEY no est√° configurado');
                }

                const sections = this.parseIssueBodyHTML(this.issueBody);
                const firstImage = this.extractFirstImage(this.issueBody);

                console.log('üìã Contenido parseado:', {
                  issueTitle: this.issueTitle,
                  parsedTitle: sections.title,
                  descriptionLength: sections.description.length,
                  fuentesCount: sections.fuentes.length,
                  fuentes: sections.fuentes.slice(0, 3), 
                  firstImage: firstImage || 'ninguna'
                });

                const finalTitle = sections.title || this.issueTitle.replace(/^\[Info\]\s*/i, '').trim();
                
                if (!finalTitle || finalTitle.length < 3) {
                  throw new Error('El t√≠tulo es muy corto o est√° vac√≠o');
                }

                if (!sections.description || sections.description.length < 500) {
                  throw new Error('La descripci√≥n debe tener al menos 500 caracteres');
                }

                if (sections.fuentes.length < 3) {
                  throw new Error('Debe proporcionar al menos 3 fuentes (URLs)');
                }

                if (!firstImage) {
                  throw new Error('Debe incluir al menos una imagen');
                }

                const imageBuffer = await this.downloadAndProcessImage(firstImage);
                await this.validateContent(sections.description, sections.fuentes, imageBuffer);

                await fs.mkdir(CONFIG.targetDir, { recursive: true });

                const sanitizedTitle = this.sanitizeFilename(finalTitle);
                const fileInfo = await this.findAvailableFilename(sanitizedTitle, this.issueUser);
                const finalFilename = fileInfo.filename;

                await this.saveProcessedImage(finalFilename);

                console.log('üìù Creando archivo markdown...');
                await this.createMarkdownFile(
                  finalFilename, 
                  finalTitle, 
                  sections.description, 
                  sections.fuentes, 
                  this.issueUser
                );

                process.chdir(process.env.GITHUB_WORKSPACE);

                await execAsync('git config --global user.name "GitHub Action"');
                await execAsync('git config --global user.email "action@github.com"');

                console.log('üì§ Realizando commit...');
                const commitMessage = `${CONFIG.baseCommitMessage} ${finalFilename} ${CONFIG.botSignature}`;
                await execAsync('git add .');
                await execAsync(`git commit -m "${commitMessage}"`);
                await execAsync('git push');

                let successMessage = `Entrada creada exitosamente: **${finalTitle}**\n\n`;
                successMessage += `üìÅ Archivo: \`${finalFilename}.md\`\n`;
                successMessage += `üë§ Usuario: ${this.issueUser}\n`;
                successMessage += `üìä Fuentes encontradas: ${sections.fuentes.length}\n`;
                
                if (fileInfo.canReplace) {
                  successMessage += `üîÑ Archivo reemplazado (mismo usuario)\n`;
                } else if (finalFilename !== sanitizedTitle) {
                  successMessage += `üî¢ Nuevo archivo creado (conflicto de nombre)\n`;
                }

                await this.addComment(successMessage);
                await this.closeIssue();

                console.log('‚úÖ Issue procesado exitosamente');

              } catch (error) {
                console.error('‚ùå Error procesando issue:', error);
                await this.addComment(error.message, true);
              }
            }
          }

          const processor = new IssueProcessor();
          processor.process();
          EOF

          node process_issue.js
