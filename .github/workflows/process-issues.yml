name: 'Procesar Issues Autom√°ticamente'

on:
  issues:
    types: [opened, edited]

jobs:
  process-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          pip install requests

      - name: Process Issue
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_USER: ${{ github.event.issue.user.login }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        working-directory: ${{ github.workspace }}
        run: |
          python3 << 'EOF'
          import os
          import json
          import re
          import subprocess
          import requests
          import base64
          import unicodedata
          from pathlib import Path
          from typing import Dict, List, Optional, Tuple

          class IssueProcessor:
              def __init__(self):
                  self.target_dir = Path(os.environ['GITHUB_WORKSPACE']) / 'web' / 'Dinamico' / 'Corrupcion'
                  self.groq_api_key = os.environ.get('GROQ_API_KEY')
                  self.github_token = os.environ.get('GITHUB_TOKEN')
                  self.github_repo = os.environ.get('GITHUB_REPOSITORY')
                  self.issue_number = os.environ.get('ISSUE_NUMBER')
                  self.issue_title = os.environ.get('ISSUE_TITLE', '')
                  self.issue_body = os.environ.get('ISSUE_BODY', '')
                  self.issue_user = os.environ.get('ISSUE_USER', '')
                  
                  self.image_prompt = """Analiza esta imagen y responde √öNICAMENTE con "APTA" o "NO_APTA".
          
          Una imagen es APTA si:
          - Es apropiada para todo p√∫blico
          - No contiene contenido sexual, pornogr√°fico o desnudos
          - No contiene violencia extrema o gore
          - Es relevante para contenido informativo/period√≠stico
          
          Una imagen es NO_APTA si:
          - Contiene desnudos o contenido sexual
          - Muestra violencia extrema o sangre excesiva
          - Es claramente inapropiada para menores
          
          Responde solo: APTA o NO_APTA"""

                  self.text_prompt = """Analiza el siguiente texto y fuentes, y responde √öNICAMENTE con "VALIDO" o "INVALIDO".
          
          El texto es V√ÅLIDO si:
          - Tiene coherencia y estructura l√≥gica
          - Presenta informaci√≥n detallada y espec√≠fica
          - Las fuentes son enlaces v√°lidos y relevantes
          - No es claramente spam, troll o sin sentido
          - Tiene al menos 500 caracteres de contenido sustancial
          - Las fuentes proporcionan contexto o evidencia
          
          El texto es INV√ÅLIDO si:
          - Es muy corto o sin informaci√≥n √∫til
          - Es claramente spam o troll
          - Las fuentes no son relevantes o son falsas
          - Contiene solo texto sin sentido
          - Contiene Scripts Sospechosos no relacionado a reproduccion multimedia
          
          Responde solo: VALIDO o INVALIDO"""

              def make_groq_request(self, prompt: str, image_url: Optional[str] = None) -> str:
                  """Hace una petici√≥n a la API de Groq."""
                  messages = []
                  
                  if image_url:
                      messages.append({
                          'role': 'user',
                          'content': [
                              {'type': 'text', 'text': prompt},
                              {'type': 'image_url', 'image_url': {'url': image_url}}
                          ]
                      })
                      model = 'meta-llama/llama-4-maverick-17b-128e-instruct'
                  else:
                      messages.append({
                          'role': 'user',
                          'content': prompt
                      })
                      model = 'llama-3.3-70b-versatile'

                  response = requests.post(
                      'https://api.groq.com/openai/v1/chat/completions',
                      headers={
                          'Authorization': f'Bearer {self.groq_api_key}',
                          'Content-Type': 'application/json'
                      },
                      json={
                          'messages': messages,
                          'model': model,
                          'temperature': 0.1,
                          'max_tokens': 100
                      }
                  )
                  
                  if not response.ok:
                      raise Exception(f'Groq API Error: {response.status_code}')
                  
                  data = response.json()
                  return data['choices'][0]['message']['content'].strip()

              def parse_issue_body(self, body: str) -> Dict[str, any]:
                  """Parsea el cuerpo del issue para extraer t√≠tulo, descripci√≥n y fuentes."""
                  sections = {
                      'title': '',
                      'description': '',
                      'fuentes': []
                  }

                  # Extraer t√≠tulo
                  title_match = re.search(r'### üìå T√≠tulo\s*\n\n(.*?)(?=\n### |$)', body, re.DOTALL)
                  if title_match:
                      sections['title'] = title_match.group(1).strip()

                  # Extraer descripci√≥n
                  desc_match = re.search(r'### üìù Descripci√≥n\s*\r?\n+([\s\S]*?)(?=\n### |$)', body)
                  if desc_match:
                      sections['description'] = desc_match.group(1).strip()

                  # Extraer fuentes
                  fuentes_match = re.search(r'### üîó Fuentes\s*\n\n(.*?)(?=\n### |$)', body, re.DOTALL)
                  if fuentes_match:
                      fuentes_text = fuentes_match.group(1).strip()
                      
                      # Buscar todas las URLs
                      url_regex = r'https?://[^\s<>"{}|\\^`\[\]]+'
                      urls = re.findall(url_regex, fuentes_text)
                      
                      # Buscar URLs en l√≠neas con guiones
                      lines = fuentes_text.split('\n')
                      line_urls = []
                      for line in lines:
                          line = line.strip()
                          if line.startswith('-') or line.startswith('*'):
                              url_match = re.search(url_regex, line)
                              if url_match:
                                  line_urls.append(url_match.group(0))
                      
                      # Combinar y eliminar duplicados
                      all_urls = list(set(urls + line_urls))
                      sections['fuentes'] = all_urls

                  return sections

              def extract_images(self, body: str) -> List[str]:
                  """Extrae URLs de im√°genes del cuerpo del issue."""
                  images = []
                  
                  # Im√°genes markdown: ![alt](url)
                  markdown_matches = re.findall(r'!\[.*?\]\((https?://[^\)]+)\)', body)
                  images.extend(markdown_matches)
                  
                  # Im√°genes HTML: <img src="url">
                  html_matches = re.findall(r'<img[^>]+src=["\'](https?://[^"\']+)["\'][^>]*>', body)
                  images.extend(html_matches)
                  
                  # URLs de GitHub assets
                  github_matches = re.findall(r'https://github\.com/user-attachments/assets/[a-f0-9\-]+', body)
                  images.extend(github_matches)
                  
                  # Eliminar duplicados
                  return list(set(images))

              def sanitize_filename(self, filename: str) -> str:
                  """Sanitiza un nombre de archivo para uso seguro."""
                  # Normalizar caracteres Unicode
                  filename = unicodedata.normalize('NFD', filename)
                  # Remover acentos
                  filename = re.sub(r'[\u0300-\u036f]', '', filename)
                  # Solo letras, n√∫meros, espacios, guiones y guiones bajos
                  filename = re.sub(r'[^\w\s\-_]', '', filename)
                  # Espacios por guiones bajos
                  filename = re.sub(r'\s+', '_', filename)
                  # M√∫ltiples guiones bajos por uno solo
                  filename = re.sub(r'_+', '_', filename)
                  # Remover guiones bajos al inicio/final
                  filename = filename.strip('_')
                  # Min√∫sculas y m√°ximo 50 caracteres
                  return filename.lower()[:50]

              def clean_title_for_commit(self, title: str) -> str:
                  """Limpia un t√≠tulo para uso seguro en comandos git."""
                  # Remover HTML/markdown tags
                  title = re.sub(r'<[^>]+>', '', title)
                  # Remover markdown images ![alt](url)
                  title = re.sub(r'!\[.*?\]\([^)]+\)', '', title)
                  # Remover saltos de l√≠nea y espacios extra
                  title = re.sub(r'\s+', ' ', title)
                  # Remover caracteres problem√°ticos para comandos shell
                  title = re.sub(r'[<>"|&;name: 'Procesar Issues Autom√°ticamente'

on:
  issues:
    types: [opened, edited]

jobs:
  process-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          pip install requests

      - name: Process Issue
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_USER: ${{ github.event.issue.user.login }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        working-directory: ${{ github.workspace }}
        run: |
          python3 << 'EOF'
          import os
          import json
          import re
          import subprocess
          import requests
          import base64
          import unicodedata
          from pathlib import Path
          from typing import Dict, List, Optional, Tuple

          class IssueProcessor:
              def __init__(self):
                  self.target_dir = Path(os.environ['GITHUB_WORKSPACE']) / 'web' / 'Dinamico' / 'Corrupcion'
                  self.groq_api_key = os.environ.get('GROQ_API_KEY')
                  self.github_token = os.environ.get('GITHUB_TOKEN')
                  self.github_repo = os.environ.get('GITHUB_REPOSITORY')
                  self.issue_number = os.environ.get('ISSUE_NUMBER')
                  self.issue_title = os.environ.get('ISSUE_TITLE', '')
                  self.issue_body = os.environ.get('ISSUE_BODY', '')
                  self.issue_user = os.environ.get('ISSUE_USER', '')
                  
                  self.image_prompt = """Analiza esta imagen y responde √öNICAMENTE con "APTA" o "NO_APTA".
          
          Una imagen es APTA si:
          - Es apropiada para todo p√∫blico
          - No contiene contenido sexual, pornogr√°fico o desnudos
          - No contiene violencia extrema o gore
          - Es relevante para contenido informativo/period√≠stico
          
          Una imagen es NO_APTA si:
          - Contiene desnudos o contenido sexual
          - Muestra violencia extrema o sangre excesiva
          - Es claramente inapropiada para menores
          
          Responde solo: APTA o NO_APTA"""

                  self.text_prompt = """Analiza el siguiente texto y fuentes, y responde √öNICAMENTE con "VALIDO" o "INVALIDO".
          
          El texto es V√ÅLIDO si:
          - Tiene coherencia y estructura l√≥gica
          - Presenta informaci√≥n detallada y espec√≠fica
          - Las fuentes son enlaces v√°lidos y relevantes
          - No es claramente spam, troll o sin sentido
          - Tiene al menos 500 caracteres de contenido sustancial
          - Las fuentes proporcionan contexto o evidencia
          
          El texto es INV√ÅLIDO si:
          - Es muy corto o sin informaci√≥n √∫til
          - Es claramente spam o troll
          - Las fuentes no son relevantes o son falsas
          - Contiene solo texto sin sentido
          - Contiene Scripts Sospechosos no relacionado a reproduccion multimedia
          
          Responde solo: VALIDO o INVALIDO"""

              def make_groq_request(self, prompt: str, image_url: Optional[str] = None) -> str:
                  """Hace una petici√≥n a la API de Groq."""
                  messages = []
                  
                  if image_url:
                      messages.append({
                          'role': 'user',
                          'content': [
                              {'type': 'text', 'text': prompt},
                              {'type': 'image_url', 'image_url': {'url': image_url}}
                          ]
                      })
                      model = 'meta-llama/llama-4-maverick-17b-128e-instruct'
                  else:
                      messages.append({
                          'role': 'user',
                          'content': prompt
                      })
                      model = 'llama-3.3-70b-versatile'

                  response = requests.post(
                      'https://api.groq.com/openai/v1/chat/completions',
                      headers={
                          'Authorization': f'Bearer {self.groq_api_key}',
                          'Content-Type': 'application/json'
                      },
                      json={
                          'messages': messages,
                          'model': model,
                          'temperature': 0.1,
                          'max_tokens': 100
                      }
                  )
                  
                  if not response.ok:
                      raise Exception(f'Groq API Error: {response.status_code}')
                  
                  data = response.json()
                  return data['choices'][0]['message']['content'].strip()

              def parse_issue_body(self, body: str) -> Dict[str, any]:
                  """Parsea el cuerpo del issue para extraer t√≠tulo, descripci√≥n y fuentes."""
                  sections = {
                      'title': '',
                      'description': '',
                      'fuentes': []
                  }

                  # Extraer t√≠tulo
                  title_match = re.search(r'### üìå T√≠tulo\s*\n\n(.*?)(?=\n### |$)', body, re.DOTALL)
                  if title_match:
                      sections['title'] = title_match.group(1).strip()

                  # Extraer descripci√≥n
                  desc_match = re.search(r'### üìù Descripci√≥n\s*\r?\n+([\s\S]*?)(?=\n### |$)', body)
                  if desc_match:
                      sections['description'] = desc_match.group(1).strip()

                  # Extraer fuentes
                  fuentes_match = re.search(r'### üîó Fuentes\s*\n\n(.*?)(?=\n### |$)', body, re.DOTALL)
                  if fuentes_match:
                      fuentes_text = fuentes_match.group(1).strip()
                      
                      # Buscar todas las URLs
                      url_regex = r'https?://[^\s<>"{}|\\^`\[\]]+'
                      urls = re.findall(url_regex, fuentes_text)
                      
                      # Buscar URLs en l√≠neas con guiones
                      lines = fuentes_text.split('\n')
                      line_urls = []
                      for line in lines:
                          line = line.strip()
                          if line.startswith('-') or line.startswith('*'):
                              url_match = re.search(url_regex, line)
                              if url_match:
                                  line_urls.append(url_match.group(0))
                      
                      # Combinar y eliminar duplicados
                      all_urls = list(set(urls + line_urls))
                      sections['fuentes'] = all_urls

                  return sections

              def extract_images(self, body: str) -> List[str]:
                  """Extrae URLs de im√°genes del cuerpo del issue."""
                  images = []
                  
                  # Im√°genes markdown: ![alt](url)
                  markdown_matches = re.findall(r'!\[.*?\]\((https?://[^\)]+)\)', body)
                  images.extend(markdown_matches)
                  
                  # Im√°genes HTML: <img src="url">
                  html_matches = re.findall(r'<img[^>]+src=["\'](https?://[^"\']+)["\'][^>]*>', body)
                  images.extend(html_matches)
                  
                  # URLs de GitHub assets
                  github_matches = re.findall(r'https://github\.com/user-attachments/assets/[a-f0-9\-]+', body)
                  images.extend(github_matches)
                  
                  # Eliminar duplicados
                  return list(set(images))

\\]', '', title)
                  # Truncar si es muy largo
                  title = title.strip()[:100]
                  return title

              def file_exists(self, filepath: Path) -> bool:
                  """Verifica si un archivo existe."""
                  return filepath.exists()

              def find_available_filename(self, base_filename: str, username: str) -> Dict[str, any]:
                  """Encuentra un nombre de archivo disponible o verifica si se puede reemplazar."""
                  base_path = self.target_dir / f'{base_filename}.md'
                  
                  if not self.file_exists(base_path):
                      return {'filename': base_filename, 'isNew': True}

                  try:
                      # Leer archivo existente
                      with open(base_path, 'r', encoding='utf-8') as f:
                          existing_content = f.read()
                      
                      existing_user = self.extract_user_from_file(existing_content)
                      
                      if username and existing_user == username:
                          return {'filename': base_filename, 'canReplace': True}
                      
                      # Buscar nombre alternativo
                      counter = 1
                      while True:
                          new_filename = f'{base_filename}_{counter}'
                          new_path = self.target_dir / f'{new_filename}.md'
                          if not self.file_exists(new_path):
                              return {'filename': new_filename, 'isNew': True}
                          counter += 1
                          
                  except Exception as e:
                      print(f'Error leyendo archivo existente: {e}')
                      raise

              def extract_user_from_file(self, content: str) -> Optional[str]:
                  """Extrae el usuario de un archivo markdown."""
                  match = re.search(r'<!-- participant: (\w+) -->', content)
                  return match.group(1) if match else None

              def download_image(self, image_url: str, filename: str) -> Path:
                  """Descarga una imagen y la guarda."""
                  print(f'üì• Descargando imagen desde: {image_url}')
                  
                  headers = {}
                  if 'github.com/user-attachments/assets' in image_url:
                      headers['Authorization'] = f'token {self.github_token}'
                      headers['Accept'] = 'application/vnd.github.v3.raw'
                  
                  response = requests.get(image_url, headers=headers)
                  
                  if not response.ok:
                      raise Exception(f'Error descargando imagen: {response.status_code}')

                  print(f'üì¶ Imagen descargada, tama√±o: {len(response.content)} bytes')
                  
                  image_path = self.target_dir / f'{filename}.jpg'
                  with open(image_path, 'wb') as f:
                      f.write(response.content)
                  
                  print(f'üíæ Imagen guardada en: {image_path}')
                  return image_path

              def validate_content(self, description: str, fuentes: List[str], first_image: str) -> bool:
                  """Valida el contenido usando IA."""
                  print('üîç Validando contenido con IA...')

                  if first_image:
                      print(f'üì∏ Validando imagen: {first_image}')
                      
                      try:
                          image_for_validation = first_image
                          
                          # Para im√°genes de GitHub assets, convertir a base64
                          if 'github.com/user-attachments/assets' in first_image:
                              print('üì± Descargando imagen de GitHub para validaci√≥n...')
                              headers = {
                                  'Authorization': f'token {self.github_token}',
                                  'Accept': 'application/vnd.github.v3.raw'
                              }
                              response = requests.get(first_image, headers=headers)
                              
                              if response.ok:
                                  encoded_image = base64.b64encode(response.content).decode('utf-8')
                                  image_for_validation = f'data:image/jpeg;base64,{encoded_image}'
                          
                          image_result = self.make_groq_request(self.image_prompt, image_for_validation)
                          print(f'Resultado imagen: {image_result}')
                          
                          if 'NO_APTA' in image_result:
                              raise Exception('La imagen no es apropiada para todo p√∫blico')
                              
                      except Exception as image_error:
                          print(f'‚ö†Ô∏è No se pudo validar la imagen: {image_error}')
                          print('üìù Continuando solo con validaci√≥n de texto...')

                  # Validar texto y fuentes
                  print('üìù Validando texto y fuentes...')
                  text_to_validate = f"""
          DESCRIPCI√ìN:
          {description}
          
          FUENTES:
          {chr(10).join(fuentes)}
          """
                  
                  text_result = self.make_groq_request(f'{self.text_prompt}\n\nTEXTO A ANALIZAR:\n{text_to_validate}')
                  print(f'Resultado texto: {text_result}')
                  
                  if 'INVALIDO' in text_result:
                      raise Exception('El contenido del texto o las fuentes no son v√°lidos')

                  print('‚úÖ Validaci√≥n exitosa')
                  return True

              def create_markdown_file(self, filename: str, title: str, description: str, fuentes: List[str], username: str) -> Path:
                  """Crea el archivo markdown."""
                  content = ''
                  if username:
                      content += f'<!-- participant: {username} -->\n\n'
                  
                  content += f'# {title}\n\n'
                  content += f'{description}\n\n'
                  
                  if fuentes:
                      content += '## Fuentes\n\n'
                      for fuente in fuentes:
                          content += f'- {fuente}\n'

                  file_path = self.target_dir / f'{filename}.md'
                  with open(file_path, 'w', encoding='utf-8') as f:
                      f.write(content)
                  
                  return file_path

              def add_comment(self, message: str, is_error: bool = False) -> None:
                  """A√±ade un comentario al issue."""
                  comment_body = f"{'‚ùå **Error**' if is_error else '‚úÖ **√âxito**'}: {message}"
                  
                  response = requests.post(
                      f'https://api.github.com/repos/{self.github_repo}/issues/{self.issue_number}/comments',
                      headers={
                          'Authorization': f'token {self.github_token}',
                          'Content-Type': 'application/json'
                      },
                      json={'body': comment_body}
                  )
                  
                  if not response.ok:
                      print(f'Error a√±adiendo comentario: {response.status_code}')

              def close_issue(self) -> None:
                  """Cierra el issue."""
                  response = requests.patch(
                      f'https://api.github.com/repos/{self.github_repo}/issues/{self.issue_number}',
                      headers={
                          'Authorization': f'token {self.github_token}',
                          'Content-Type': 'application/json'
                      },
                      json={'state': 'closed'}
                  )
                  
                  if not response.ok:
                      print(f'Error cerrando issue: {response.status_code}')

              def run_git_command(self, command: str) -> None:
                  """Ejecuta un comando git en el directorio del workspace."""
                  workspace_dir = os.environ['GITHUB_WORKSPACE']
                  result = subprocess.run(
                      command.split(), 
                      capture_output=True, 
                      text=True, 
                      cwd=workspace_dir
                  )
                  if result.returncode != 0:
                      print(f"Error ejecutando: {command}")
                      print(f"STDOUT: {result.stdout}")
                      print(f"STDERR: {result.stderr}")
                      print(f"Working directory: {workspace_dir}")
                      raise Exception(f'Git command failed: {result.stderr}')

              def process(self) -> None:
                  """Procesa el issue principal."""
                  try:
                      print(f'üöÄ Procesando issue #{self.issue_number} de {self.issue_user}')

                      if not self.groq_api_key:
                          raise Exception('GROQ_API_KEY no est√° configurado')

                      # Parsear contenido del issue
                      sections = self.parse_issue_body(self.issue_body)
                      images = self.extract_images(self.issue_body)

                      print('üìã Contenido parseado:', {
                          'issueTitle': self.issue_title,
                          'parsedTitle': sections['title'],
                          'descriptionLength': len(sections['description']),
                          'fuentesCount': len(sections['fuentes']),
                          'fuentes': sections['fuentes'][:3],  # Primeras 3 para log
                          'imagesCount': len(images),
                          'firstImage': images[0] if images else 'ninguna'
                      })

                      # Validaciones b√°sicas
                      final_title = sections['title'] or re.sub(r'^\[Info\]\s*', '', self.issue_title, flags=re.IGNORECASE).strip()
                      
                      # Limpiar t√≠tulo de HTML/markdown para uso seguro
                      clean_title = self.clean_title_for_commit(final_title)
                      
                      if not clean_title or len(clean_title) < 3:
                          raise Exception('El t√≠tulo es muy corto o est√° vac√≠o despu√©s de limpieza')

                      if not sections['description'] or len(sections['description']) < 500:
                          raise Exception('La descripci√≥n debe tener al menos 500 caracteres')

                      if len(sections['fuentes']) < 3:
                          raise Exception('Debe proporcionar al menos 3 fuentes')

                      if len(images) == 0:
                          raise Exception('Debe incluir al menos una imagen')

                      # Crear directorio objetivo
                      self.target_dir.mkdir(parents=True, exist_ok=True)

                      # Determinar nombre de archivo
                      issue_title_clean = re.sub(r'^\[Info\]\s*', '', self.issue_title, flags=re.IGNORECASE).strip()
                      sanitized_title = self.sanitize_filename(issue_title_clean)
                      file_info = self.find_available_filename(sanitized_title, self.issue_user)
                      final_filename = file_info['filename']

                      # Descargar imagen UNA SOLA VEZ
                      print('üì• Descargando imagen...')
                      image_path, image_bytes = self.download_image_once(images[0], final_filename)

                      # Validar con IA (usando los bytes ya descargados)
                      self.validate_content(sections['description'], sections['fuentes'], images[0], image_bytes)

                      # Crear archivo markdown
                      print('üìù Creando archivo markdown...')
                      self.create_markdown_file(
                          final_filename,
                          clean_title,  # Usar t√≠tulo limpio
                          sections['description'],
                          sections['fuentes'],
                          self.issue_user
                      )

                      # Configurar git y hacer commit
                      self.run_git_command('git config --global user.name "GitHub Action"')
                      self.run_git_command('git config --global user.email "action@github.com"')

                      print('üì§ Realizando commit...')
                      self.run_git_command('git add .')
                      self.run_git_command('git commit -m "Nueva entrada"')
                      self.run_git_command('git push')

                      # Mensaje de √©xito
                      success_message = f'Entrada creada exitosamente: **{clean_title}**\n\n'
                      success_message += f'üìÅ Archivo: `{final_filename}.md`\n'
                      success_message += f'üë§ Usuario: {self.issue_user}\n'
                      success_message += f'üìä Fuentes encontradas: {len(sections["fuentes"])}\n'
                      
                      if file_info.get('canReplace'):
                          success_message += 'üîÑ Archivo reemplazado (mismo usuario)\n'
                      elif final_filename != sanitized_title:
                          success_message += 'üî¢ Nuevo archivo creado (conflicto de nombre)\n'

                      self.add_comment(success_message)
                      self.close_issue()

                      print('‚úÖ Issue procesado exitosamente')

                  except Exception as error:
                      print(f'‚ùå Error procesando issue: {error}')
                      self.add_comment(str(error), is_error=True)

          # Ejecutar el procesador
          if __name__ == '__main__':
              processor = IssueProcessor()
              processor.process()
          EOF
