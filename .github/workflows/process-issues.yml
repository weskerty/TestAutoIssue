name: 'Procesar Issues Autom√°ticamente'

on:
  issues:
    types: [opened, edited]

jobs:
  process-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm init -y
          npm install node-fetch form-data

      - name: Process Issue
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_USER: ${{ github.event.issue.user.login }}
        run: |
          cat > process_issue.js << 'EOF'
          const fs = require('fs').promises;
          const path = require('path');
          const { exec } = require('child_process');
          const { promisify } = require('util');

          const execAsync = promisify(exec);

          // Configuraci√≥n
          const CONFIG = {
            targetDir: 'web/Dinamico/Corrupcion',
            groqApiKey: process.env.GROQ_API_KEY,
            githubToken: process.env.GITHUB_TOKEN,
            
            // Configuraci√≥n de prompts de IA
            imagePrompt: `Analiza esta imagen y responde √öNICAMENTE con "APTA" o "NO_APTA".
            
            Una imagen es APTA si:
            - Es apropiada para todo p√∫blico
            - No contiene contenido sexual, pornogr√°fico o desnudos
            - No contiene violencia extrema o gore
            - Es relevante para contenido informativo/period√≠stico
            
            Una imagen es NO_APTA si:
            - Contiene desnudos o contenido sexual
            - Muestra violencia extrema o sangre excesiva
            - Es claramente inapropiada para menores
            
            Responde solo: APTA o NO_APTA`,

            textPrompt: `Analiza el siguiente texto y fuentes, y responde √öNICAMENTE con "VALIDO" o "INVALIDO".
            
            El texto es V√ÅLIDO si:
            - Tiene coherencia y estructura l√≥gica
            - Presenta informaci√≥n detallada y espec√≠fica
            - Las fuentes son enlaces v√°lidos y relevantes
            - No es claramente spam, troll o sin sentido
            - Tiene al menos 500 caracteres de contenido sustancial
            - Las fuentes proporcionan contexto o evidencia
            
            El texto es INV√ÅLIDO si:
            - Es muy corto o sin informaci√≥n √∫til
            - Es claramente spam o troll
            - Las fuentes no son relevantes o son falsas
            - Contiene solo texto sin sentido
            - No aporta informaci√≥n valiosa
            
            Responde solo: VALIDO o INVALIDO`
          };

          class IssueProcessor {
            constructor() {
              this.issueNumber = process.env.ISSUE_NUMBER;
              this.issueTitle = process.env.ISSUE_TITLE;
              this.issueBody = process.env.ISSUE_BODY;
              this.issueUser = process.env.ISSUE_USER;
            }

            async makeGroqRequest(prompt, imageUrl = null) {
              const fetch = (await import('node-fetch')).default;
              
              let messages = [];
              
              if (imageUrl) {
                messages.push({
                  role: 'user',
                  content: [
                    { type: 'text', text: prompt },
                    { type: 'image_url', image_url: { url: imageUrl } }
                  ]
                });
              } else {
                messages.push({
                  role: 'user',
                  content: prompt
                });
              }

              const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${CONFIG.groqApiKey}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  messages,
                  model: imageUrl ? 'llama-vision-free' : 'llama-3.3-70b-versatile',
                  temperature: 0.1,
                  max_tokens: 100
                })
              });

              if (!response.ok) {
                throw new Error(`Groq API Error: ${response.status}`);
              }

              const data = await response.json();
              return data.choices[0].message.content.trim();
            }

            parseIssueBody(body) {
              const sections = {
                title: '',
                description: '',
                fuentes: []
              };

              // Extraer t√≠tulo
              const titleMatch = body.match(/üìå T√≠tulo[^]*?### (.*?)(?:\n|$)/s);
              if (titleMatch) {
                sections.title = titleMatch[1].trim();
              }

              // Extraer descripci√≥n
              const descMatch = body.match(/üìù Descripci√≥n[^]*?### (.*?)(?=###|$)/s);
              if (descMatch) {
                sections.description = descMatch[1].trim();
              }

              // Extraer fuentes
              const fuentesMatch = body.match(/üîó Fuentes[^]*?### (.*?)(?=###|$)/s);
              if (fuentesMatch) {
                const fuentesText = fuentesMatch[1].trim();
                sections.fuentes = fuentesText.split('\n')
                  .map(line => line.trim())
                  .filter(line => line.startsWith('-') || line.startsWith('*') || line.includes('http'))
                  .map(line => line.replace(/^[-*]\s*/, '').trim());
              }

              return sections;
            }

            extractImages(body) {
              const imageRegex = /!\[.*?\]\((https?:\/\/[^\)]+)\)/g;
              const images = [];
              let match;
              
              while ((match = imageRegex.exec(body)) !== null) {
                images.push(match[1]);
              }
              
              return images;
            }

            sanitizeFilename(filename) {
              return filename
                .replace(/[^\w\s\-_]/g, '')
                .replace(/\s+/g, '_')
                .toLowerCase();
            }

            async fileExists(filepath) {
              try {
                await fs.access(filepath);
                return true;
              } catch {
                return false;
              }
            }

            async findAvailableFilename(baseFilename, username) {
              const basePath = path.join(CONFIG.targetDir, `${baseFilename}.md`);
              
              if (!(await this.fileExists(basePath))) {
                return { filename: baseFilename, isNew: true };
              }

              try {
                const existingContent = await fs.readFile(basePath, 'utf8');
                const existingUser = this.extractUserFromFile(existingContent);
                
                if (username && existingUser === username) {
                  return { filename: baseFilename, canReplace: true };
                }
                
                let counter = 1;
                let newFilename;
                let newPath;
                
                do {
                  newFilename = `${baseFilename}_${counter}`;
                  newPath = path.join(CONFIG.targetDir, `${newFilename}.md`);
                  counter++;
                } while (await this.fileExists(newPath));
                
                return { filename: newFilename, isNew: true };
                
              } catch (error) {
                console.error('Error leyendo archivo existente:', error);
                throw error;
              }
            }

            extractUserFromFile(content) {
              const match = content.match(/<!-- usuario: (\w+) -->/);
              return match ? match[1] : null;
            }

            async downloadImage(imageUrl, filename) {
              const fetch = (await import('node-fetch')).default;
              const response = await fetch(imageUrl);
              
              if (!response.ok) {
                throw new Error(`Error descargando imagen: ${response.status}`);
              }

              const buffer = await response.buffer();
              const imagePath = path.join(CONFIG.targetDir, `${filename}.jpg`);
              await fs.writeFile(imagePath, buffer);
              return imagePath;
            }

            async validateContent(description, fuentes, firstImage) {
              console.log('üîç Validando contenido con IA...');

              // Validar imagen si existe
              if (firstImage) {
                console.log('üì∏ Validando imagen...');
                const imageResult = await this.makeGroqRequest(CONFIG.imagePrompt, firstImage);
                console.log(`Resultado imagen: ${imageResult}`);
                
                if (imageResult.includes('NO_APTA')) {
                  throw new Error('La imagen no es apropiada para todo p√∫blico');
                }
              }

              // Validar texto y fuentes
              console.log('üìù Validando texto y fuentes...');
              const textToValidate = `
              DESCRIPCI√ìN:
              ${description}
              
              FUENTES:
              ${fuentes.join('\n')}
              `;
              
              const textResult = await this.makeGroqRequest(CONFIG.textPrompt + '\n\nTEXTO A ANALIZAR:\n' + textToValidate);
              console.log(`Resultado texto: ${textResult}`);
              
              if (textResult.includes('INVALIDO')) {
                throw new Error('El contenido del texto o las fuentes no son v√°lidos');
              }

              console.log('‚úÖ Validaci√≥n exitosa');
              return true;
            }

            async createMarkdownFile(filename, title, description, fuentes, username) {
              let content = '';
              if (username) {
                content += `<!-- usuario: ${username} -->\n\n`;
              }
              
              content += `# ${title}\n\n`;
              content += `${description}\n\n`;
              
              if (fuentes.length > 0) {
                content += `## Fuentes\n\n`;
                fuentes.forEach(fuente => {
                  content += `- ${fuente}\n`;
                });
              }

              const filePath = path.join(CONFIG.targetDir, `${filename}.md`);
              await fs.writeFile(filePath, content, 'utf8');
              return filePath;
            }

            async addComment(message, isError = false) {
              const fetch = (await import('node-fetch')).default;
              
              const commentBody = isError ? 
                `‚ùå **Error**: ${message}` : 
                `‚úÖ **√âxito**: ${message}`;

              await fetch(`https://api.github.com/repos/${process.env.GITHUB_REPOSITORY}/issues/${this.issueNumber}/comments`, {
                method: 'POST',
                headers: {
                  'Authorization': `token ${CONFIG.githubToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ body: commentBody })
              });
            }

            async closeIssue() {
              const fetch = (await import('node-fetch')).default;
              
              await fetch(`https://api.github.com/repos/${process.env.GITHUB_REPOSITORY}/issues/${this.issueNumber}`, {
                method: 'PATCH',
                headers: {
                  'Authorization': `token ${CONFIG.githubToken}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ state: 'closed' })
              });
            }

            async process() {
              try {
                console.log(`üöÄ Procesando issue #${this.issueNumber} de ${this.issueUser}`);

                // Validar API key
                if (!CONFIG.groqApiKey) {
                  throw new Error('GROQ_API_KEY no est√° configurado');
                }

                // Parsear contenido del issue
                const sections = this.parseIssueBody(this.issueBody);
                const images = this.extractImages(this.issueBody);

                console.log('üìã Contenido parseado:', {
                  title: sections.title,
                  descriptionLength: sections.description.length,
                  fuentesCount: sections.fuentes.length,
                  imagesCount: images.length
                });

                // Validaciones b√°sicas
                if (!sections.title || sections.title.length < 3) {
                  throw new Error('El t√≠tulo es muy corto o est√° vac√≠o');
                }

                if (!sections.description || sections.description.length < 500) {
                  throw new Error('La descripci√≥n debe tener al menos 500 caracteres');
                }

                if (sections.fuentes.length < 3) {
                  throw new Error('Debe proporcionar al menos 3 fuentes');
                }

                if (images.length === 0) {
                  throw new Error('Debe incluir al menos una imagen');
                }

                // Validar contenido con IA
                await this.validateContent(sections.description, sections.fuentes, images[0]);

                // Crear directorio si no existe
                await fs.mkdir(CONFIG.targetDir, { recursive: true });

                // Determinar nombre de archivo
                const sanitizedTitle = this.sanitizeFilename(sections.title);
                const fileInfo = await this.findAvailableFilename(sanitizedTitle, this.issueUser);
                const finalFilename = fileInfo.filename;

                // Descargar primera imagen
                console.log('üì• Descargando imagen...');
                await this.downloadImage(images[0], finalFilename);

                // Crear archivo markdown
                console.log('üìù Creando archivo markdown...');
                await this.createMarkdownFile(
                  finalFilename, 
                  sections.title, 
                  sections.description, 
                  sections.fuentes, 
                  this.issueUser
                );

                // Configurar git
                await execAsync('git config --global user.name "GitHub Action"');
                await execAsync('git config --global user.email "action@github.com"');

                // Commit y push
                console.log('üì§ Realizando commit...');
                await execAsync('git add .');
                await execAsync(`git commit -m "Nueva entrada: ${sections.title} (Issue #${this.issueNumber})"`);
                await execAsync('git push');

                // Mensaje de √©xito
                let successMessage = `Entrada creada exitosamente: **${sections.title}**\n\n`;
                successMessage += `üìÅ Archivo: \`${finalFilename}.md\`\n`;
                successMessage += `üë§ Usuario: ${this.issueUser}\n`;
                
                if (fileInfo.canReplace) {
                  successMessage += `üîÑ Archivo reemplazado (mismo usuario)\n`;
                } else if (finalFilename !== sanitizedTitle) {
                  successMessage += `üî¢ Nuevo archivo creado (conflicto de nombre)\n`;
                }

                await this.addComment(successMessage);
                await this.closeIssue();

                console.log('‚úÖ Issue procesado exitosamente');

              } catch (error) {
                console.error('‚ùå Error procesando issue:', error);
                await this.addComment(error.message, true);
              }
            }
          }

          // Ejecutar procesador
          const processor = new IssueProcessor();
          processor.process();
          EOF

          node process_issue.js
